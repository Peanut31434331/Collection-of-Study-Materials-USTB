/*
 * generated by Xtext 2.25.0
 */
package org.xtext.test.minijava.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.test.minijava.minijava.Addition;
import org.xtext.test.minijava.minijava.ClassDeclaration;
import org.xtext.test.minijava.minijava.Expr;
import org.xtext.test.minijava.minijava.Expression;
import org.xtext.test.minijava.minijava.Goal;
import org.xtext.test.minijava.minijava.MainClass;
import org.xtext.test.minijava.minijava.Method;
import org.xtext.test.minijava.minijava.MethodCall;
import org.xtext.test.minijava.minijava.MinijavaPackage;
import org.xtext.test.minijava.minijava.Multiplication;
import org.xtext.test.minijava.minijava.NumberValue;
import org.xtext.test.minijava.minijava.Point;
import org.xtext.test.minijava.minijava.QualifiedNameLi;
import org.xtext.test.minijava.minijava.QualifiedNameList;
import org.xtext.test.minijava.minijava.SquareBrackets;
import org.xtext.test.minijava.minijava.Statement;
import org.xtext.test.minijava.minijava.Type;
import org.xtext.test.minijava.minijava.VarDeclaration;
import org.xtext.test.minijava.minijava.Variable;
import org.xtext.test.minijava.services.MinijavaGrammarAccess;

@SuppressWarnings("all")
public class MinijavaSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MinijavaGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MinijavaPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MinijavaPackage.ADDITION:
				sequence_Addition(context, (Addition) semanticObject); 
				return; 
			case MinijavaPackage.CLASS_DECLARATION:
				sequence_ClassDeclaration(context, (ClassDeclaration) semanticObject); 
				return; 
			case MinijavaPackage.EXPR:
				if (rule == grammarAccess.getAdditionRule()
						|| action == grammarAccess.getAdditionAccess().getAdditionLeftAction_1_0()) {
					sequence_Addition(context, (Expr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| action == grammarAccess.getExpressionAccess().getExpressionLeftAction_1_0()) {
					sequence_Expression(context, (Expr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMethodCallExprRule()) {
					sequence_MethodCallExpr(context, (Expr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMultiplicationRule()
						|| action == grammarAccess.getMultiplicationAccess().getMultiplicationLeftAction_1_0()) {
					sequence_Multiplication(context, (Expr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNegationRule()) {
					sequence_Negation(context, (Expr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNegationOrPointExpressionRule()) {
					sequence_Negation_NegationOrPointExpression(context, (Expr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPointRule()
						|| action == grammarAccess.getPointAccess().getPointLeftAction_1_0()) {
					sequence_Point(context, (Expr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryRule()) {
					sequence_Primary(context, (Expr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSquareBracketsRule()
						|| action == grammarAccess.getSquareBracketsAccess().getSquareBracketsLeftAction_1_0()) {
					sequence_SquareBrackets(context, (Expr) semanticObject); 
					return; 
				}
				else break;
			case MinijavaPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case MinijavaPackage.GOAL:
				sequence_Goal(context, (Goal) semanticObject); 
				return; 
			case MinijavaPackage.MAIN_CLASS:
				sequence_MainClass(context, (MainClass) semanticObject); 
				return; 
			case MinijavaPackage.METHOD:
				sequence_MethodDeclaration(context, (Method) semanticObject); 
				return; 
			case MinijavaPackage.METHOD_CALL:
				sequence_MethodCall(context, (MethodCall) semanticObject); 
				return; 
			case MinijavaPackage.MULTIPLICATION:
				sequence_Multiplication(context, (Multiplication) semanticObject); 
				return; 
			case MinijavaPackage.NUMBER_VALUE:
				sequence_NumberValue(context, (NumberValue) semanticObject); 
				return; 
			case MinijavaPackage.POINT:
				sequence_Point(context, (Point) semanticObject); 
				return; 
			case MinijavaPackage.QUALIFIED_NAME_LI:
				sequence_QualifiedNameLi(context, (QualifiedNameLi) semanticObject); 
				return; 
			case MinijavaPackage.QUALIFIED_NAME_LIST:
				sequence_QualifiedNameList(context, (QualifiedNameList) semanticObject); 
				return; 
			case MinijavaPackage.SQUARE_BRACKETS:
				sequence_SquareBrackets(context, (SquareBrackets) semanticObject); 
				return; 
			case MinijavaPackage.STATEMENT:
				sequence_Statement(context, (Statement) semanticObject); 
				return; 
			case MinijavaPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case MinijavaPackage.VAR_DECLARATION:
				if (rule == grammarAccess.getVarDeclarationRule()) {
					sequence_VarDeclaration(context, (VarDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVarLiRule()) {
					sequence_VarDeclaration_VarLi(context, (VarDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVarListRule()) {
					sequence_VarDeclaration_VarList(context, (VarDeclaration) semanticObject); 
					return; 
				}
				else break;
			case MinijavaPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Addition returns Addition
	 *     Addition.Addition_1_0 returns Addition
	 *
	 * Constraint:
	 *     (left=Addition_Addition_1_0 (expressionType='+' | expressionType='-') right=Multiplication)
	 */
	protected void sequence_Addition(ISerializationContext context, Addition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Addition returns Expr
	 *     Addition.Addition_1_0 returns Expr
	 *
	 * Constraint:
	 *     multiplication=Multiplication
	 */
	protected void sequence_Addition(ISerializationContext context, Expr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinijavaPackage.Literals.EXPR__MULTIPLICATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinijavaPackage.Literals.EXPR__MULTIPLICATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionAccess().getMultiplicationMultiplicationParserRuleCall_0_0(), semanticObject.getMultiplication());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ClassDeclaration returns ClassDeclaration
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         qualifiedName=[ClassDeclaration|ID]? 
	 *         qualifiedNameList=QualifiedNameList? 
	 *         (varDeclarations+=VarDeclaration | methodDeclarations+=MethodDeclaration)*
	 *     )
	 */
	protected void sequence_ClassDeclaration(ISerializationContext context, ClassDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expr
	 *     Expression.Expression_1_0 returns Expr
	 *
	 * Constraint:
	 *     addition=Addition
	 */
	protected void sequence_Expression(ISerializationContext context, Expr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinijavaPackage.Literals.EXPR__ADDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinijavaPackage.Literals.EXPR__ADDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getAdditionAdditionParserRuleCall_0_0(), semanticObject.getAddition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *
	 * Constraint:
	 *     (left=Expression_Expression_1_0 expressionType='<' right=Expression)
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinijavaPackage.Literals.EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinijavaPackage.Literals.EXPR__LEFT));
			if (transientValues.isValueTransient(semanticObject, MinijavaPackage.Literals.EXPR__EXPRESSION_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinijavaPackage.Literals.EXPR__EXPRESSION_TYPE));
			if (transientValues.isValueTransient(semanticObject, MinijavaPackage.Literals.EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinijavaPackage.Literals.EXPR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionAccess().getExpressionTypeLessThanSignKeyword_1_1_0(), semanticObject.getExpressionType());
		feeder.accept(grammarAccess.getExpressionAccess().getRightExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Goal returns Goal
	 *
	 * Constraint:
	 *     (package=PackageDecl? importdecl+=ImportDecl* classDeclarations+=MainClass classDeclarations+=ClassDeclaration*)
	 */
	protected void sequence_Goal(ISerializationContext context, Goal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MainClass returns MainClass
	 *
	 * Constraint:
	 *     (name=ID (varDeclarations+=VarDeclaration | methodDeclarations+=MethodDeclaration | statement=Statement)*)
	 */
	protected void sequence_MainClass(ISerializationContext context, MainClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MethodCallExpr returns Expr
	 *
	 * Constraint:
	 *     (expressionType='length' | methodCall=MethodCall)
	 */
	protected void sequence_MethodCallExpr(ISerializationContext context, Expr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MethodCall returns MethodCall
	 *
	 * Constraint:
	 *     (method=[Method|ID] (parameters+=Expression parameters+=Expression*)?)
	 */
	protected void sequence_MethodCall(ISerializationContext context, MethodCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MethodDeclaration returns Method
	 *
	 * Constraint:
	 *     (
	 *         methodType=Type 
	 *         name=ID 
	 *         varList=VarList? 
	 *         localVarDeclarations+=VarDeclaration* 
	 *         statements+=Statement* 
	 *         returnExpression=Expression?
	 *     )
	 */
	protected void sequence_MethodDeclaration(ISerializationContext context, Method semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Multiplication returns Expr
	 *     Multiplication.Multiplication_1_0 returns Expr
	 *
	 * Constraint:
	 *     negationOrPointExpression=NegationOrPointExpression
	 */
	protected void sequence_Multiplication(ISerializationContext context, Expr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinijavaPackage.Literals.EXPR__NEGATION_OR_POINT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinijavaPackage.Literals.EXPR__NEGATION_OR_POINT_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getNegationOrPointExpressionNegationOrPointExpressionParserRuleCall_0_0(), semanticObject.getNegationOrPointExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Multiplication returns Multiplication
	 *     Multiplication.Multiplication_1_0 returns Multiplication
	 *
	 * Constraint:
	 *     (left=Multiplication_Multiplication_1_0 (expressionType='*' | expressionType='&&') right=NegationOrPointExpression)
	 */
	protected void sequence_Multiplication(ISerializationContext context, Multiplication semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Negation returns Expr
	 *
	 * Constraint:
	 *     (expressionType='!' right=Point)
	 */
	protected void sequence_Negation(ISerializationContext context, Expr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinijavaPackage.Literals.EXPR__EXPRESSION_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinijavaPackage.Literals.EXPR__EXPRESSION_TYPE));
			if (transientValues.isValueTransient(semanticObject, MinijavaPackage.Literals.EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinijavaPackage.Literals.EXPR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNegationAccess().getExpressionTypeExclamationMarkKeyword_0_0(), semanticObject.getExpressionType());
		feeder.accept(grammarAccess.getNegationAccess().getRightPointParserRuleCall_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NegationOrPointExpression returns Expr
	 *
	 * Constraint:
	 *     (point=Point | (expressionType='!' right=Point))
	 */
	protected void sequence_Negation_NegationOrPointExpression(ISerializationContext context, Expr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NumberValue returns NumberValue
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_NumberValue(ISerializationContext context, NumberValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinijavaPackage.Literals.NUMBER_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinijavaPackage.Literals.NUMBER_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberValueAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Point returns Expr
	 *     Point.Point_1_0 returns Expr
	 *
	 * Constraint:
	 *     squareBrackets=SquareBrackets
	 */
	protected void sequence_Point(ISerializationContext context, Expr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinijavaPackage.Literals.EXPR__SQUARE_BRACKETS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinijavaPackage.Literals.EXPR__SQUARE_BRACKETS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointAccess().getSquareBracketsSquareBracketsParserRuleCall_0_0(), semanticObject.getSquareBrackets());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Point returns Point
	 *     Point.Point_1_0 returns Point
	 *
	 * Constraint:
	 *     (left=Point_Point_1_0 expressionType='.' right=MethodCallExpr)
	 */
	protected void sequence_Point(ISerializationContext context, Point semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinijavaPackage.Literals.EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinijavaPackage.Literals.EXPR__LEFT));
			if (transientValues.isValueTransient(semanticObject, MinijavaPackage.Literals.EXPR__EXPRESSION_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinijavaPackage.Literals.EXPR__EXPRESSION_TYPE));
			if (transientValues.isValueTransient(semanticObject, MinijavaPackage.Literals.EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinijavaPackage.Literals.EXPR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointAccess().getPointLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPointAccess().getExpressionTypeFullStopKeyword_1_1_0(), semanticObject.getExpressionType());
		feeder.accept(grammarAccess.getPointAccess().getRightMethodCallExprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Primary returns Expr
	 *
	 * Constraint:
	 *     (
	 *         expressionType='true' | 
	 *         expressionType='false' | 
	 *         expressionType='this' | 
	 *         (expressionType='new' expression=Expression) | 
	 *         (expressionType='new' type=Type) | 
	 *         (expressionType='(' expression=Expression) | 
	 *         variable=[Variable|ID] | 
	 *         number=NumberValue
	 *     )
	 */
	protected void sequence_Primary(ISerializationContext context, Expr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     QualifiedNameLi returns QualifiedNameLi
	 *
	 * Constraint:
	 *     (qualifiedName=QualifiedName qualifiedNameLi=QualifiedNameLi)
	 */
	protected void sequence_QualifiedNameLi(ISerializationContext context, QualifiedNameLi semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinijavaPackage.Literals.QUALIFIED_NAME_LI__QUALIFIED_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinijavaPackage.Literals.QUALIFIED_NAME_LI__QUALIFIED_NAME));
			if (transientValues.isValueTransient(semanticObject, MinijavaPackage.Literals.QUALIFIED_NAME_LI__QUALIFIED_NAME_LI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinijavaPackage.Literals.QUALIFIED_NAME_LI__QUALIFIED_NAME_LI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getQualifiedNameLiAccess().getQualifiedNameQualifiedNameParserRuleCall_1_0(), semanticObject.getQualifiedName());
		feeder.accept(grammarAccess.getQualifiedNameLiAccess().getQualifiedNameLiQualifiedNameLiParserRuleCall_2_0(), semanticObject.getQualifiedNameLi());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     QualifiedNameList returns QualifiedNameList
	 *
	 * Constraint:
	 *     (qualifiedName=QualifiedName qualifiedNameLi=QualifiedNameLi?)
	 */
	protected void sequence_QualifiedNameList(ISerializationContext context, QualifiedNameList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SquareBrackets returns Expr
	 *     SquareBrackets.SquareBrackets_1_0 returns Expr
	 *
	 * Constraint:
	 *     primary=Primary
	 */
	protected void sequence_SquareBrackets(ISerializationContext context, Expr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinijavaPackage.Literals.EXPR__PRIMARY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinijavaPackage.Literals.EXPR__PRIMARY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSquareBracketsAccess().getPrimaryPrimaryParserRuleCall_0_0(), semanticObject.getPrimary());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SquareBrackets returns SquareBrackets
	 *
	 * Constraint:
	 *     (left=SquareBrackets_SquareBrackets_1_0 expressionType='[' right=Primary)
	 */
	protected void sequence_SquareBrackets(ISerializationContext context, SquareBrackets semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinijavaPackage.Literals.EXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinijavaPackage.Literals.EXPR__LEFT));
			if (transientValues.isValueTransient(semanticObject, MinijavaPackage.Literals.EXPR__EXPRESSION_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinijavaPackage.Literals.EXPR__EXPRESSION_TYPE));
			if (transientValues.isValueTransient(semanticObject, MinijavaPackage.Literals.EXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinijavaPackage.Literals.EXPR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSquareBracketsAccess().getSquareBracketsLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSquareBracketsAccess().getExpressionTypeLeftSquareBracketKeyword_1_1_0(), semanticObject.getExpressionType());
		feeder.accept(grammarAccess.getSquareBracketsAccess().getRightPrimaryParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Statement
	 *
	 * Constraint:
	 *     (
	 *         (statementType='{' statements+=Statement*) | 
	 *         (statementType='if' firstExpression=Expression statements+=Statement statements+=Statement) | 
	 *         (statementType='while' firstExpression=Expression statements+=Statement) | 
	 *         (variable=[Variable|ID] statementType='=' firstExpression=Expression) | 
	 *         (variable=[Variable|ID] isArrayElementAssignment?='[' firstExpression=Expression statementType='=' secondExpression=Expression)
	 *     )
	 */
	protected void sequence_Statement(ISerializationContext context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *
	 * Constraint:
	 *     (
	 *         typeName='[' | 
	 *         typeName='int' | 
	 *         typeName='boolean' | 
	 *         typeName='double' | 
	 *         typeName='char' | 
	 *         qualifiedName=QualifiedName | 
	 *         varList=VarList
	 *     )
	 */
	protected void sequence_Type(ISerializationContext context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarDeclaration returns VarDeclaration
	 *
	 * Constraint:
	 *     variable=Variable
	 */
	protected void sequence_VarDeclaration(ISerializationContext context, VarDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinijavaPackage.Literals.VAR_DECLARATION__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinijavaPackage.Literals.VAR_DECLARATION__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarDeclarationAccess().getVariableVariableParserRuleCall_0_0(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarLi returns VarDeclaration
	 *
	 * Constraint:
	 *     (variable=Variable varLi=VarLi)
	 */
	protected void sequence_VarDeclaration_VarLi(ISerializationContext context, VarDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinijavaPackage.Literals.VAR_DECLARATION__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinijavaPackage.Literals.VAR_DECLARATION__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, MinijavaPackage.Literals.VAR_DECLARATION__VAR_LI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinijavaPackage.Literals.VAR_DECLARATION__VAR_LI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarDeclarationAccess().getVariableVariableParserRuleCall_0_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getVarLiAccess().getVarLiVarLiParserRuleCall_2_0(), semanticObject.getVarLi());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarList returns VarDeclaration
	 *
	 * Constraint:
	 *     (variable=Variable varLi=VarLi)
	 */
	protected void sequence_VarDeclaration_VarList(ISerializationContext context, VarDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinijavaPackage.Literals.VAR_DECLARATION__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinijavaPackage.Literals.VAR_DECLARATION__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, MinijavaPackage.Literals.VAR_DECLARATION__VAR_LI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinijavaPackage.Literals.VAR_DECLARATION__VAR_LI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarDeclarationAccess().getVariableVariableParserRuleCall_0_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getVarListAccess().getVarLiVarLiParserRuleCall_1_0(), semanticObject.getVarLi());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     (variableType=Type name=ID)
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MinijavaPackage.Literals.VARIABLE__VARIABLE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinijavaPackage.Literals.VARIABLE__VARIABLE_TYPE));
			if (transientValues.isValueTransient(semanticObject, MinijavaPackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MinijavaPackage.Literals.VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getVariableTypeTypeParserRuleCall_0_0(), semanticObject.getVariableType());
		feeder.accept(grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
